using BurgerLink.Order.Contracts;using BurgerLink.Order.Entity;using BurgerLink.Order.Services;using MassTransit;using MassTransit.Courier;using MongoDB.Driver;using System.Net.Http.Json;using System.Text.Json;namespace BurgerLink.Order.Activities;public class IngredientValidatedActivity : IExecuteActivity<IngredientValidated>{    private readonly IOrderService _orderService;    public IngredientValidatedActivity(IOrderService orderService)    {        _orderService = orderService;    }    public async Task<ExecutionResult> Execute(ExecuteContext<IngredientValidated> context)    {
        await AddIngredientToOrder(context);        await SendStatusUpdate(context);        return context.Completed();    }    private static async Task SendStatusUpdate(ExecuteContext<IngredientValidated> context)    {
        var canFindValid = context.Message.Variables.TryGetValue<bool>("Valid", out var valid);        var canFindUpdate = context.Message.Variables.TryGetValue<Uri>("StatusUpdateAddress", out var uri);        if (!canFindValid || !canFindUpdate)        {            return;        }        var status = new Status        {            OrderName = context.Arguments.OrderName,            IngredientName = context.Arguments.IngredientName,            Message = valid ? "ingredient added" : "invalid ingredient provided"        };        var client = new HttpClient();        client.BaseAddress = uri;        await client.PostAsJsonAsync((string?)null, status, new JsonSerializerOptions(JsonSerializerDefaults.Web), CancellationToken.None);    }

    private async Task AddIngredientToOrder(ExecuteContext<IngredientValidated> context)    {        var canFindValid = context.Message.Variables.TryGetValue<bool>("Valid", out var valid);        if (!canFindValid || !valid)        {            return;        }        var filter = MongoDbFilters.OrderFilter(context.Arguments.OrderName);        var updateDefinition = Builders<OrderEntity>            .Update            .Push(entity => entity.Ingredients, context.Arguments.IngredientName);        await _orderService.Collection.UpdateOneAsync(filter, updateDefinition);    }}